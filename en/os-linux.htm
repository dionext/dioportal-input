<html xmlns="http://www.w3.org/1999/xhtml" xmlns:og="http://ogp.me/ns#" lang="en"> 
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /> 
        <meta charset="utf-8" /> 
        <meta http-equiv="Content-Language" content="en" />
        <title>OS Linux</title>
        <meta name="description" content="" />
        <meta name="keywords" content="" />
    </head>
    <body> 
        <h1>OS Linux</h1> 
        <div> 
            <ul class="list-unstyled" id="TOC"> 
                <li><a href="#id0">Versions</a></li> 
                <li><a href="#id1">Useful settings</a></li> 
                <li><a href="#id2">&#xa0;&#xa0;&#xa0;&#xa0;Open SSH access</a></li> 
                <li><a href="#id3">&#xa0;&#xa0;&#xa0;&#xa0;Change language</a></li> 
                <li><a href="#id4">&#xa0;&#xa0;&#xa0;&#xa0;Change timezone</a></li> 
                <li><a href="#id5">&#xa0;&#xa0;&#xa0;&#xa0;Change server name</a></li> 
                <li><a href="#id6">Users and groups</a></li> 
                <li><a href="#id7">Working with the file system</a></li> 
                <li><a href="#id8">&#xa0;&#xa0;&#xa0;&#xa0;File Manager</a></li> 
                <li><a href="#id9">&#xa0;&#xa0;&#xa0;&#xa0;Information</a></li> 
                <li><a href="#id10">&#xa0;&#xa0;&#xa0;&#xa0;Moving through files, searching</a></li> 
                <li><a href="#id11">&#xa0;&#xa0;&#xa0;&#xa0;Copying, deleting</a></li> 
                <li><a href="#id12">&#xa0;&#xa0;&#xa0;&#xa0;rsync</a></li> 
                <li><a href="#id13">&#xa0;&#xa0;&#xa0;&#xa0;scp</a></li> 
                <li><a href="#id14">&#xa0;&#xa0;&#xa0;&#xa0;Editing files</a></li> 
                <li><a href="#id15">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;nano</a></li> 
                <li><a href="#id30">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;vi</a></li> 
                <li><a href="#id16">&#xa0;&#xa0;&#xa0;&#xa0;Compressing</a></li> 
                <li><a href="#id17">&#xa0;&#xa0;&#xa0;&#xa0;Downloading files from outside</a></li> 
                <li><a href="#id18">Commands and scripts</a></li> 
                <li><a href="#id19">&#xa0;&#xa0;&#xa0;&#xa0;Run</a></li> 
                <li><a href="#id20">&#xa0;&#xa0;&#xa0;&#xa0;Scripts</a></li> 
                <li><a href="#id21">&#xa0;&#xa0;&#xa0;&#xa0;Environment Variables</a></li> 
                <li><a href="#id22">&#xa0;&#xa0;&#xa0;&#xa0;View services and processes</a></li> 
                <li><a href="#id23">&#xa0;&#xa0;&#xa0;&#xa0;Turn on, turn off, reboot</a></li> 
                <li><a href="#id24">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;Disable sleeping mode</a></li> 
                <li><a href="#id25">&#xa0;&#xa0;&#xa0;&#xa0;Long processes through "screen"</a></li> 
                <li><a href="#id26">&#xa0;&#xa0;&#xa0;&#xa0;Scheduler - crontab</a></li> 
                <li><a href="#id27">Disk and partition layout, formatting, mounting, disk loading information</a></li> 
                <li><a href="#id28">&#xa0;&#xa0;&#xa0;&#xa0;Displaying information (including information about free space)</a></li> 
                <li><a href="#id29">&#xa0;&#xa0;&#xa0;&#xa0;Adding a Hard Drive in Linux</a></li> 
                <li><a href="#id31">&#xa0;&#xa0;&#xa0;&#xa0;Mounting</a></li> 
                <li><a href="#id32">&#xa0;&#xa0;&#xa0;&#xa0;Permanent mount</a></li> 
                <li><a href="#id33">Monitoring</a></li> 
                <li><a href="#id34">&#xa0;&#xa0;&#xa0;&#xa0;Memory</a></li> 
                <li><a href="#id75">&#xa0;&#xa0;&#xa0;&#xa0;Hardware Monitoring</a></li> 
                <li><a href="#id35">References</a></li> 
            </ul>
        </div> 
        <h2><a name="id0"></a>Versions</h2> 
        <pre><code class="language-bash">root@ubuntuserversico:~# cat /proc/version<br />
Linux version 5.15.0-83-generic (buildd@lcy02-amd64-027) (gcc (Ubuntu 
11.4.0-1ubuntu1~22.04) 11.4.0, GNU ld (GNU Binutils for Ubuntu) 2.38) #92-Ubuntu 
SMP Mon Aug 14 09:30:42 UTC 2023</code></pre> 
        <h2><a name="id1"></a>Useful settings</h2> 
        <h3><a name="id2"></a>Open SSH access</h3> Debian 
        <br /> 
        <br /> To enable SSH login for a root user on Debian Linux system you need to first configure SSH server. Open /etc/ssh/sshd_config and change the following line: 
        <br /> nano /etc/ssh/sshd_config 
        <br /> 
        <p>&#xa0;</p> FROM: 
        <br /> PermitRootLogin without-password 
        <br /> TO: 
        <br /> PermitRootLogin yes 
        <br /> 
        <br /> Once you made the above change restart your SSH server: # /etc/init.d/ssh restart 
        <br /> [ ok ] Restarting ssh (via systemctl): ssh.service. 
        <br /> 
        <br /> Ubuntu 
        <br /> http://ubuntuhandbook.org/index.php/2016/04/enable-ssh-ubuntu-16-04-lts/ 
        <br /> sudo passwd root 
        <p>&#xa0;</p> &#xa0;sudo sed -i 's/prohibit-password/yes/' /etc/ssh/sshd_config 
        <br /> or manually open sshd configuration file /etc/ssh/sshd_config and change line: 
        <br /> sudo nano /etc/ssh/sshd_config 
        <br /> 
        <br /> FROM: 
        <br /> PermitRootLogin prohibit-password 
        <br /> TO: 
        <br /> PermitRootLogin yes 
        <br /> Once you have made the above configuration change restart ssh daemon: 
        <br /> $ sudo systemctl restart sshd 
        <br /> (or restart server) 
        <h3><a name="id3"></a>Change language</h3> 
        <pre><code class="language-bash">
env | grep LANG
export LANG=en_US.UTF-8
dpkg-reconfigure locales
</code></pre> 
        <h3><a name="id4"></a>Change timezone</h3> 
        <pre><code class="language-bash">
timedatectl 
set-timezone America/New_York
</code></pre> 
        <h3><a name="id5"></a>Change server name</h3> 
        <p>The procedure to change the computer name on Ubuntu Linux:<br /> <br /> Type the following command to edit /etc/hostname using nano or vi text editor: </p> 
        <pre><code class="language-bash">sudo nano /etc/hostname</code></pre> Delete the old name and setup new name. Next Edit the /etc/hosts file: 
        <br /> 
        <pre><code class="language-bash">sudo nano /etc/hosts</code></pre> Replace any occurrence of the existing computer name with your new one. 
        <br /> Reboot the system to changes take effect: 
        <br /> 
        <pre><code class="language-bash">sudo reboot</code></pre> 
        <h2><a name="id6"></a>Users and groups</h2> 
        <p>entering root mode<br /> <pre><code class="language-bash">
sudo su</code></pre><br /> setting a password (and actually activating) root<br /> <pre><code class="language-bash">
sudo passwd root</code></pre><br /> <a href="https://andreyex.ru/linux/ponimanie-fajla-etc-shadow/" rel="nofollow" target="_blank" class="external">https://andreyex.ru/linux/ponimanie-fajla-etc-shadow/</a> How to check (password is encrypted). If the password field contains an asterisk ( *) or exclamation mark ( !), the user will not be able to log in using password authentication. Other login methods, such as key-based authentication or switching to user, are still allowed<br /> <pre><code class="language-bash">
sudo cat /etc/shadow | grep root</code></pre>Utilities:</p> 
        <ul> 
            <li>sudo is a utility for launching programs with superuser rights, for example, to run the mc program with superuser rights, you need to type “sudo mc” - this will allow you to edit system files in the etc folder.</li> 
            <li>whoami - display the name under which you are registered.</li> 
        </ul> 
        <p>For a complete list of user accounts, one account per line:<br /> <pre><code class="language-bash">less /etc/passwd</code></pre> <p>The /etc/passwd file consists of user records, one to a line. Each record contains multiple fields, separated by colons (:). The fields are: <br /> <br /> • username <span lang="en-us">&#xa0;</span>• encrypted password (or x if shadow passwords are in use) <span lang="en-us">&#xa0;</span>• UID • default GID • real name (also known as the GECOS field) • home directory • default shell <br /> </p> For a complete list of groups, one group per line:<br /> <pre><code class="language-bash">less /etc/group</code></pre> <p>The /etc/group file consists of group records, one to a line. Each record contains multiple fields, separated by colons (:). The fields are: <br /> <br /> • group name • encrypted group password (or x if shadow passwords are in use) • GID • group members' usernames, comma-separated </p> <p>Adding a user</p> <pre><code class="language-bash">adduser newuser</code></pre> <p>temporary (until the exit command) switching to a new user<br /> </p> <pre><code class="language-bash">su - newuser</code></pre> <p>Changing the root password<br /> •To change password of any account when login as root, use command: passwd<br /> •To change password of a group, use command: passwd -g<br /> <pre><code class="language-bash">sudo passwd root</code></pre> Or, if you’re running as root already (which you shouldn’t be), just:<br /> <pre><code class="language-bash">passwd</code></pre>Deleting a user<span lang="ru">. </span>User accounts can be removed using the userdel command.<span lang="ru"> </span>The basic syntax of the userdel command is userdel username.<br /> <br /> <span lang="ru">P</span>ermissions<br /> <br /> chmod &lt;permissions=""&gt; &lt;file&gt; - change the permissions for a file that you own. (-R recursion)<br /> reading - read (r), writing - write (w), execution - execute (x) and three types of users:<br /> the owner of the file is owner (u), members of the same group as the owner of the file (g) and everyone else (o).<br /> You can check your current access rights in the following way:<br /> <pre><code class="language-bash">ls -l filename</code></pre>If the file is accessible by all means to all users, then the following combination of letters will appear next to the file name:<span lang="ru">&#xa0; </span>rwxrwxrwx<span lang="ru">&#xa0; </span>The first three letters are the access rights for the file owner<span lang="ru">.</span> The second triplet is the access rights for his group<span lang="ru">.</span> The next three are the access rights for others<span lang="ru">. </span>Lack of access rights is shown as "-"<br /> <br /> For example:<br /> <br /> This command will allow you to set read permissions for the junk file for everyone (all=user+group+others):<br /> <pre><code class="language-bash">chmod a+r junk</code></pre>This command will remove the executable file permission from everyone except the user and group:<br /> <pre><code class="language-bash">chmod o-x junk</code></pre>chown &lt;new_owner&gt; &lt;files&gt; - change file owner<br /> chgrp &lt;new_group&gt; &lt;files&gt; - change the ownership group for files<br /> <h2><a name="id7"></a>Working with the file system</h2> <h3><a name="id8"></a>File Manager</h3> <pre><code class="language-bash">apt-get install mc</code></pre> <h3><a name="id9"></a>Information</h3> <p>du<br /> </p> <p>Without passing any parameters, the du command prints the name and size of each folder in the current path, including all subdirectories in the output: To get folder sizes in a more readable format, namely kilobytes (K), megabytes (M) or gigabytes (G) use the switch -h:du -h<br /> </p> <p>du -h /home<br /> </p> <p>To find out the total size of a specific folder, call the du command with the -s switch:<br /> du -hs /home<br /> </p> <p>Another handy du command option is the --max-depth switch, which specifies the depth of folders to be viewed. If you set the depth to one, you can see the total sizes of all folders in the specified path. Execute:du -h --max-depth=1</p>
		<p>For example </p>
		<pre><code class="language-bash">
du -h /var/lib/docker/containers --max-depth=1</code></pre> <p>Free space in directory<br /> df /mnt/sdb1</p> <h3><a name="id10"></a>Moving through files, searching</h3> <p>pwd – show current location<br /> </p> <p>ls - List the files in the current directory. (ls -l - with rights) ls -a command in Linux/Unix | show all/hidden files</p> <p>cd [directory] - change the current directory. If a directory name is not specified, the user's home directory becomes the current directory.</p> <p>cat &lt;filename&gt; - outputs the contents of the file to standard output (default - to the screen).<br /> </p> <p>find &lt;directory&gt; -name filename - find a file named "filename" and display the search result on the screen. The search starts from the directory &lt;directory&gt;; "filename" may contain a search mask. (searches only in the current level)<br /> </p> <h3><a name="id11"></a>Copying, deleting</h3> <p><strong>cp&#xa0;</strong>&#xa0; &lt;copy_what&gt; &lt;copy_where&gt; - copy files.</p> <p>copy the directory <br /> <pre><code class="language-bash">cp -r /mnt/tdisks/U/Distr /mnt/pdisks/U/</code></pre> mv &lt;what to move&gt; &lt;where to move&gt; - move or rename the file.<br /> <br /> ln -s &lt;link_to&gt; &lt;link_name&gt; - create a symbolic link.<br /> <br /> rm &lt;files&gt; - delete files.<br /> <br /> mkdir &lt;directory&gt; - create a new directory.<br /> <br /> mkdir -p &lt;directory&gt;&lt;/directory&gt;directory/directory&gt; - create a new directory.<br /> <br /> rmdir &lt;directory&gt; - delete an empty directory.<br /> <br /> rm -rf &lt;files and/or="" directories=""&gt; (recursive delete) - delete files or directories and their subdirectories.<br /> <p>For example, deleting all files in a directory<br /> </p> <p>rm -rf /mnt/pdisks/U/*<br /> <br /> Note:<br /> </p> <p>cp behavior is unexpectedly different if dir2 already exists and will not be created by the cp command.<br /> </p> <p>cp -r dir1 dir2<br /> </p> <p># and similarly </p> <p>cp -r dir1/ dir2<br /> </p> <p>For an existing directory, dir2 will create a copy of the directory dir1 into dir2/dir1 instead of copying the contents of dir1 into dir2.<br /> </p> <p>Whereas<br /> </p> <p>cp -r dir1/. dir2<br /> </p> <p>It will copy the contents of dir1 to dir2.<br /> </p> <p>This is a non-obvious feature of the cp implementation. For example, rsync does not do such strange things and the following entries are equivalent:<br /> </p> <p>rsync -a dir1 dir2/<br /> rsync -a dir1/. dir2/<br /> </p> <p>(but rsync will have different behavior for writing dir2/ and dir2 for an existing directory; it is better to specify it as autocomplete suggests, ending with the path /)</p> <h3><a name="id12"></a>rsync</h3> <p>rsync - copying (synchronization) with progress indicator<br /> </p> <p>rsync is a utility for efficiently transferring and synchronizing files across computer systems. rsync has one with --progress parameter. The -a will keep permissions,etc, and -h will be human readable.<br /> <br /> rsync -ah --progress source destination</p>
		<p>rsync -rvz --progress input/images output/</p>
		<p>Use "n" to fake copy </p>
		<p>rsync -rvzn --progress input/images output/</p>
		<p><br /> </p> <h3><a name="id13"></a>scp</h3> <pre><code class="language-bash">scp -P 2023 file.tar.gz root@servername:/mnt/tdisks/U/</code></pre> <h3><a name="id14"></a>Editing files</h3> <h4><a name="id15"></a>nano</h4> <p>apt-get install nano<span lang="ru"> </span></p> <p>nano /path/file</p> <p><a href="http://help.ubuntu.ru/wiki/nano" rel="nofollow" target="_blank" class="external">http://help.ubuntu.ru/wiki/nano</a><span lang="ru"> </span></p> <p>Ctrl+X or F2 - Close and exit </p> <p>Ctrl+O or F3 - Save current file&#xa0;</p> <h4><a name="id30"></a>vi</h4> <p>If you want to edit a file using terminal, press&#xa0;i&#xa0;to go into&#xa0;insert&#xa0;mode. Edit your file and press&#xa0;ESC&#xa0;and then&#xa0;:w&#xa0;to save changes and&#xa0;:q&#xa0;to quit. However, you can combine these two like&#xa0;:wq&#xa0;to write and quit the&#xa0;vim&#xa0;editor.</p> <p>To exit the vi editor without saving the changes made to the file, use the command <strong>:q!</strong>. When the : command is entered, the cursor moves to the last line of the screen, and thus the editor is in last line mode. In this mode it is possible to enter some advanced commands. One of them is the q! command, which ends work with the vi editor without saving the changes made. The <strong>:wq</strong> command first saves the file with the changes made and then exits the vi editor. The <strong>ZZ</strong> command (issued in command mode, i.e. without entering the : command) is equivalent to the <strong>:wq</strong> command. If the file has not changed since the last modification, then the creation time of the file will also not be changed. Recall that in last line mode, command entry is completed by pressing the Enter key.<br /> To save the file but not exit the vi editor, use the <strong>:w</strong> command.</p> <h3><a name="id16"></a>Compressing</h3> <p>compressed files can be recovered using either "gzip -d" or the gunzip command.</p> <p>gunzip [file] - decompresses files compressed using the gzip utility.</p> <p>The Gunzip command deletes the archive file after extracting it. However, if you want the archive to remain, you can do so using the -c option on the command line. </p> <pre><code class="language-bash">gunzip -c file1.gz &gt; file1
gunzip -c file.gz &gt; /THERE/file</code></pre> <p>unzip [options] [zipped file] - using this command you can unzip a file compressed with the zip archiver.</p> <p>Unpacking tar.gz archive:</p> <pre><code class="language-bash">tar xzf archive-name.tar.gz</code></pre> <p>tar –xf &#xa0;tar unzipping (the archive on Windows is prepared using 7Z or on Windows 10 using the built-in OS command tar Then check file names with nonASCII)<br /> </p> <pre><code class="language-bash"># tar -xf file_name.tar -C /target/directory
# tar -xf file_name.tar.gz --directory /target/directory</code></pre> <p> <a href="https://www.tecmint.com/extract-tar-files-to-specific-or-different-directory-in-linux/" rel="nofollow" target="_blank" class="external"> https://www.tecmint.com/extract-tar-files-to-specific-or-different-directory-in-linux/</a> <br /><br /> Creating a tar.gz archive: tar -cvzf folder1.tar.gz /var/www</p> <pre><code class="language-bash">tar -cvzf folder.mnt.tar.gz /mnt</code></pre> <h3><a name="id17"></a>Downloading files from outside</h3> <p>curl http://proft.me&#xa0;&#xa0; -&#xa0; get the contents of the main page<br /> curl -o index.html http://proft.me&#xa0; - get the contents of the main page into the file index.html</p>
		<p>Curl on Ubuntu documentation
		<a href="https://manpages.ubuntu.com/manpages/focal/man1/curl.1.html">
		https://manpages.ubuntu.com/manpages/focal/man1/curl.1.html</a> </p> <h2><a name="id18"></a>Commands and scripts</h2> <h3><a name="id19"></a>Run</h3> <p>Set rights: &#xa0; </p> <pre><code class="language-bash">chmod +x filename.sh</code></pre> <p>./Program_Name - run the executable file in the current directory if the current directory is not in the list of directories specified in the PATH environment variable. <br /> <br /> alias ls="ls -Fskb --color" - create an alias so that you can run a more complex combination of commands with one command. Place the alias creation in the /etc/bashrc file if you want these aliases to be available to all users on your system<br /> </p> <p>All log files should be in one directory, which is located here: /var/log/</p> <h3><a name="id20"></a>Scripts</h3> <p class="MsoNormal"><a href="https://wiki.debian.org/BashScripting" rel="nofollow" target="_blank" class="external">https://wiki.debian.org/BashScripting</a> </p> 
                    <div id="page0" dir="ltr" lang="en"> 
                        <div id="content2" dir="ltr" lang="en"> 
                            <p class="line874">Some bash shell scripting rules: </p> 
                            <p class="line874">1) The first line in your script must be <span id="line-32" class="anchor"></span> <span id="line-33" class="anchor"></span></p> 
                            <p class="line874">#!/bin/bash <span id="line-34" class="anchor"></span> <span id="line-35" class="anchor"></span></p> 
                            <p class="line874">... that is a # (Hash) followed by a ! (ban) followed by the path of the shell. This line lets the environment know the file is a shell script and the location of the shell. <span id="line-36" class="anchor"></span> <span id="line-37" class="anchor"></span></p> 
                            <p class="line874">2) Before executing your script, you should make the script executable. You do it by using the following command: <span id="line-38" class="anchor"></span> <span id="line-39" class="anchor"></span></p> 
                            <p class="line874">$ chmod ugo+x your_shell_script.sh <span id="line-40" class="anchor"></span> <span id="line-41" class="anchor"></span></p> 
                            <p class="line874">3) The name of your shell script must end with a .sh . This lets the user know that the file is a shell script. This is not compulsary but is the norm. </p> 
                            <p>Run function from script (Example run function zero_downtime_deploy) <a href="https://stackoverflow.com/questions/8818119/how-can-i-run-a-function-from-a-script-in-command-line" rel="nofollow" target="_blank" class="external"> https://stackoverflow.com/questions/8818119/how-can-i-run-a-function-from-a-script-in-command-line</a> </p> 
                            <pre><code class="language-bash">. ./redeploy-app.sh &amp;&amp; zero_downtime_deploy</code></pre> 
                            <p class="line874">
							<a href="https://www.redhat.com/sysadmin/arguments-options-bash-scripts">
							https://www.redhat.com/sysadmin/arguments-options-bash-scripts</a> 
							Adding arguments and options to your Bash scripts </p> 
                        </div> 
                    </div> <h3><a name="id21"></a>Environment Variables</h3> <p>set|more - display the current values of environment variables. (Not for all shells. For csh/tcsh - printenv | more, although set will also show useful information.)<br /> </p> <p>echo $PATH - print the value of the environment variable "PATH" The echo command can be used to print the values of any environment variables. Use the set or printenv commands to get a complete list.</p> <h3><a name="id22"></a>View services and processes</h3> <p>! Depending on how you look at it, ps doesn't tell you how much memory a process actually uses. What this utility does do is show how much memory each process will take up as if it were the only process running.<br /> <br /> ps aux<br /> ps ax -o pid,cmd,size<br /> ps ax | grep 'search for process by part of name'<br /> ps aux | grep 'jdk'<br /> </p> <p>ps | grep &lt;your_username&gt; -display all processes running on the system under your username.<br /> <br /> ps -eo pmem,pcpu,rss,vsize,args | sort -k 1 -r | less To see a list of your running processes sorted by memory use: (! check sorting by two digits 22% comes after 3% because of two digits)</p> <p>The ps command can conveniently use the pipeline and the less utility to scroll through the displayed information using the up buttons and down, for example ps ax | lessThe second option is to use the top command. it displays information about the system load and updates it in real time.</p> <p><br /> pstree displays a tree of processes (useful for counting identical processes)<br /> </p> <p>An alternative to ps is the top command, which conveniently displays constantly updated information on the screen, but top is limited by the size of the window, so anything that cannot fit on the screen is simply ignored. </p> <p><br /> # top -p 897110<br /> <br /> kill - "kill" the process. First, determine the PID of your “killed” process using ps.<br /> killall &lt;program_name&gt; - “kill” all processes by program name.</p> <h3><a name="id23"></a>Turn on, turn off, reboot</h3> <p>The shutdown command is the main command to control stopping or rebooting a Linux system.<br /> </p> <pre><code class="language-bash">shutdown -r now</code></pre> <pre><code class="language-bash">shutdown -h now</code></pre> When using the shutdown command, you can specify a reboot at a specific time with the display of informative messages.<br /> shutdown -r 10:30 "REBOOT SYSTEM"<br /> <br /> The reboot command performs all the necessary operations to stop the system; this command can be called with the shutdown -r command, but can be used separately. This command logs the time the system was stopped, kills unfinished processes, executes the sync system call, waits for disk writing to complete, and only then stops the kernel and reboots the Linux system.<br /> <pre><code class="language-bash">reboot</code></pre> The halt command.<br /> The command is identical to the reboot command in its actions, the difference is that the halt command shuts down the system.<br /> <pre><code class="language-bash">halt</code></pre> Use the poweroff command.<br /> The poweroff command is identical to the halt command, except that after stopping the system, a special request is sent to the power management system to turn off power, allowing systems to be shut down remotely.<br /> <pre><code class="language-bash">poweroff</code></pre> <h4><a name="id24"></a>Disable sleeping mode</h4> <a href="https://askubuntu.com/questions/47311/how-do-i-disable-my-system-from-going-to-sleep" rel="nofollow" target="_blank" class="external"> How do I disable my system from going to sleep?</a> <br /> <p>On Ubuntu 16.04 LTS, I successfully used the following to disable suspend:<br /> <pre><code class="language-bash">sudo systemctl mask sleep.target suspend.target hibernate.target hybrid-sleep.target</code></pre> <p>And this to re-enable it: <code class="language-bash">sudo systemctl unmask sleep.target suspend.target hibernate.target hybrid-sleep.target</code><h3><a name="id25"></a>Long processes through "screen"</h3> <p>sudo apt-get install screen<br /> </p> <p>1. log into the remote machine (via ssh)<br /> 2. run screen there<br /> 3. run some long process inside the screen session<br /> 4. detach the screen session by pressing CTRL-A and then d (in general, all internal screen commands start with CTRL-A, for example CTRL-A + ? will show quick help)<br /> 5. exit the remote system (everything running inside screen will continue to work)<br /> 6. go to dinner, go to bed, go on vacation, do other things<br /> 7. When you want, log back into the remote machine and connect to an already running screen session by typing screen -r.<br /> </p> <p>Additional commands:&#xa0; </p> <p>list of running processes </p> <p>screen -ls&#xa0;&#xa0;&#xa0;&#xa0; </p> <p>Closing from inside</p> <p>exit<br /> </p> <p>Closing from outside session you can copy fromscreen -ls) </p> <p>screen -X -S [session # you want to kill] quit</p> <p> <br /> Ctrl+a -&gt; c With this command we created a new screen and now they work simultaneously<br /> <br /> To switch between screens, you can either specify the screen number or select a screen from the list:<br /> Ctrl+a -&gt; 0 will take us to screen 0.<br /> Ctrl+a -&gt; “ will bring up a menu for selecting a screenshot<br /> Ctrl+a -&gt;n will switch to the next screen<br /> Ctrl+a -&gt;p will switch to the previous screen<br /> <br /> Regions are being closed with hotkeys<br /> Ctrl+a -&gt;Q Close all regions except the current one<br /> Ctrl+a -&gt;X Close current region </p> <h3><a name="id26"></a>Scheduler - crontab</h3> <a href="https://www.computerhope.com/unix/ucrontab.htm" rel="nofollow" target="_blank" class="external"> https://www.computerhope.com/unix/ucrontab.htm</a> <br /> <p>List of tasks for the current user:</p> <pre><code class="language-bash">crontab -l</code></pre> <p>List of tasks for user with name vasua:</p> <pre><code class="language-bash">crontab -u vasua -l</code></pre> <p>List of tasks for all users</p> <pre><code class="language-bash">for user in $(cut -d':' -f1 /etc/passwd); do crontab -u $user -l; done</code></pre> Edit <br /> <pre><code class="language-bash">crontab -e</code></pre> <p>On a default installation the cron jobs get logged to /var/log/syslog</p> <h2><a name="id27"></a>Disk and partition layout, formatting, mounting, disk loading information</h2> <h3><a name="id28"></a>Displaying information (including information about free space)</h3> <p>df 
		-h - display information about free and used space on disks (mounted 
		partitions)<br /> </p> <p>hdparm -I /dev/sda will output information about the physical media mounted on /dev/sda<br /> </p> <p>Working with the fdisk utility on Linux <a href="http://www.oldnix.org/fdisk-linux/" rel="nofollow" target="_blank" class="external">http://www.oldnix.org/fdisk-linux/</a><br /> </p> <p>fdisk -l &#xa0;print full information<br /> </p> <h3><a name="id29"></a>Adding a Hard Drive in Linux</h3> <p><a href="http://www.linuxlib.ru/iron/hddadd.htm" rel="nofollow" target="_blank" class="external">http://www.linuxlib.ru/iron/hddadd.htm</a>&#xa0; <a href="http://mydebianblog.blogspot.ru/2008/09/linux.html" rel="nofollow" target="_blank" class="external">http://mydebianblog.blogspot.ru/2008/09/linux.html</a>&#xa0; </p> <p><a href="https://pve.proxmox.com/wiki/Resize_disks" rel="nofollow" target="_blank" class="external">https://pve.proxmox.com/wiki/Resize_disks</a> </p> <p>view information about all physical and virtual disks</p> <pre><code class="language-bash">fdisk -l</code></pre> <p>view information about the first physical or virtual disk</p> <pre><code class="language-bash">fdisk -l /dev/sda</code></pre> <p>find your new drive. it can be for example /dev/vdb /dev/vdc /dev/sda4 - this must be taken into account in further commands</p> <pre><code class="language-bash">fdisk /dev/vdc</code></pre> <p>Create a new partition with n. Then select the partition type by entering the p command. Leave the remaining parameters unchanged by simply pressing Enter. To save your changes, enter the w command.</p> <p>formats the vdc1 partition into ext4 format</p> <pre><code class="language-bash">mkfs.ext4 /dev/vdc1</code></pre> <p>create the mount folder</p> <pre><code class="language-bash">mkdir /mnt/disk2</code></pre> <pre><code class="language-bash">mount -o barrier=0 /dev/vdc1 /mnt/disk2</code></pre> <pre><code class="language-bash">echo "/dev/vdc1 /mnt/disk2 ext4 barrier=0 0 1" &gt;&gt; /etc/fstab</code></pre> <p>Check the disk names in the system, for example, with the lsblk command</p> <p>&#xa0;</p> <h3><a name="id31"></a>Mounting</h3> <p>Simple</p> <pre><code class="language-bash">mount -t ext3 /dev/sda4 /mnt/sda4</code></pre><br /> mounting with opening rights<br /> (may give a parameter mismatch error, which depends, in particular, on the type of file system)<br /> <pre><code class="language-bash">mount -t ext4 -o umask=000 UUID=4b1cfd17-5f09-42ba-8cbe-d0c959562489 /mnt/drive</code></pre> <pre><code class="language-bash">
mount -t auto /dev/sdb1 /mnt/sdb1 -o umask=0,nls=utf8</code></pre> <h3><a name="id32"></a>Permanent mount</h3> <p><span lang="ru">Note:</span> If there is an error in the commands, the system will not start</p> <p><span lang="ru">F</span>or permanent mounting add it to /etc/fstab<br /> <pre><code class="language-bash">/dev/sda4 /mnt/sda4 ext3 defaults 0 0</code></pre> <p>With expanded access rights (umask=0 may give an error)<br /> <pre><code class="language-bash">/dev/sdb1 /mnt/sdb1 auto umask=0,nls=utf8,exec,user,auto,rw 0 0</code></pre> <p>View mounted<br /> </p> <pre><code class="language-bash">cat /etc/fstab view automount</code></pre> <h2><a name="id33"></a>Monitoring</h2> <h3><a name="id34"></a>Memory</h3> <p>free - display information on memory usage. (outputs in kb by default)<br /> -b,-k,-m,-g show output in bytes, KB, MB, or GB</p> <h3><a name="id75"></a>Hardware Monitoring</h3> lm-sensors - a set of utilities for reading the values of temperature, voltage and cooler speed sensors. Using these utilities, you can answer the question “What is the current temperature of my processor?”<br /> <br /> 1.Install lm-sensors:<br /> <br /> apt-get install lm-sensors<br /> <br /> 2. Determine the presence of sensors in the system:<br /> <br /> sensors-detect<br /> <br /> 3. Load the missing drivers:<br /> <br /> modprobe &lt;missing modules=""&gt;<br /> <br /> 4. And that’s it, look at the sensor values:<br /> <br /> sensors<br /> &lt;/missing&gt; <h2><a name="id35"></a>References</h2> <p class="MsoNormal">&#xa0;<a href="http://www.jinr.ru/unixinfo/usersguide/" rel="nofollow" target="_blank" class="external">http://www.jinr.ru/unixinfo/usersguide/</a> (lang: rus)</p> <p class="MsoNormal">Red Hat Enterprise Linux 4 Руководство по системному администрированию<br /> <a href="http://www.rhd.ru/docs/manuals/enterprise/RHEL-4-Manual/sysadmin-guide/index.html" rel="nofollow" target="_blank" class="external"> http://www.rhd.ru/docs/manuals/enterprise/RHEL-4-Manual/sysadmin-guide/index.html</a> (lang: rus)</p> <br /> <a href="http://homes-smart.ru/index.php/oborudovanie/raspberry-pi/azbuka-po-linux-sistemam" rel="nofollow" target="_blank" class="external"> http://homes-smart.ru/index.php/oborudovanie/raspberry-pi/azbuka-po-linux-sistemam</a> (lang: rus) </p></p></p></p></p></p></p> 
    </body>
</html>